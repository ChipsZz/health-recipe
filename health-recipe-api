export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const path = url.pathname;

    // 路由
    const router = {
        // 登录
        '/api/login': () => login(request, env),
        // 生成食谱
        '/api/recipe/generate': () => generateRecipe(request, env),
        // 上传饮食记录
        '/api/food/upload': () => foodUpload(request, env),
        // 保存饮食记录
        '/api/food/save': () => foodSave(request, env),
        // 查看饮食记录
        '/api/food/query': () => foodQuery(request, env),
    };

    // 处理请求
    const handler = router[path];
    return handler();
  }
};

async function login(request, env) {
  try{
      const { user_name, type } = await request.json();

      let user_id = "";
      let user = await env.DB.prepare('SELECT id as user_id FROM users WHERE username = ?').bind(user_name).first();
      if (user == null) {
          user_id = crypto.randomUUID();
          await env.DB.prepare('INSERT INTO users (id, username) VALUES (?, ?)').bind(user_id, user_name).run();
      } else {
          user_id = user.user_id
          // 注册时用户已存在
          if (type == 2) {
              return Response.json({"message": "user exist"});
          }
      }
      return Response.json({user_id, user_name});
  } catch (error) {
      return new Response(error.message, { status: 500 });
  }
} 

async function generateRecipe(request, env) {
    try{
        const{ input, preference } = await request.json();

        // 1.检索食谱知识
        const queryText = `Recommended recipes, goal: ${input}`;
        const queryVector = await env.AI.run('@cf/baai/bge-m3', { text: queryText });
        
        const vectors = await env.VECTORIZE_INDEX.query(queryVector.data[0], {
            topK: 1,
            returnMetadata: true
        });
        
        const context = vectors.matches.reduce((prev, current) => {
          if (!current.metadata) return prev;
          const productTexts = Object.entries(current.metadata).map(
              ([key, value]) => {
                  switch (key) {
                  case "name":
                      return `## ${value}`;
                  case "product_metadata":
                      return `- ${key}: ${JSON.stringify(value)}`;
                  default:
                      return `- ${key}: ${value}`;
                  }
              },
          );
          const productTextData = productTexts.join("\n");
          return `${prev}\n${productTextData}`;
        }, "");

        // 2.获取食谱
        const prompt = `
          You are a professional nutritionist. If there is user demand, please recommend personalized healthy recipes based on user needs. If not, recommend related recipes.
          ## User Needs (Optional)
          ${input}

          ## User Preferences (Optional)
          ${preference}
          
          ## Expertise Reference (Optional)
          Please refer to the following recipe knowledge to create a personalized healthy recipe:
          ${context}

          ## Language Detection and Response Strategy
          1. Automatically detect the language of user input
          2. Reply in the exact language the user inputs
          3. If the user uses multiple languages, the primary or first language will prevail
          4. Maintain consistency in language style and idioms

          ## Example:
          - User inputs in Chinese → Reply in Chinese
          - User inputs in English → Reply in English

          Ensure that the language of all replies exactly matches the language the user inputs.
          
          ## Important Guidelines
          1. Use the provided expert knowledge context to design a personalized healthy recipe.
          2. Provide accurate calorie and nutrient estimates.
        `;
        
        const data = await env.AI.run('@cf/meta/llama-3.1-8b-instruct-fast', {
          messages: [
              {
                  role: 'system',
                  content: prompt,
              }, 
              {
                  role: 'user',
                  content: input,
              }
          ], 
          max_tokens: 5000,
          // stream: true,
        });
        return new Response(JSON.stringify(data));
    } catch (error) {
        return new Response(error.message, { status: 500 });
    }
}

async function foodUpload(request, env) {
  try{
      if (request.method !== 'POST') {
          return new Response('Method not allowed', { status: 405 });
      }

      const formData = await request.formData();
      const imageFile = formData.get('image');

      if (!imageFile || !(imageFile instanceof File)) {
          return new Response('file empty', { status: 400 });
      }

      if (!imageFile.type.startsWith('image/')) {
          return new Response('required image', { status: 400 });
      }

      const maxSize = 5 * 1024 * 1024;
      if (imageFile.size > maxSize) {
          return new Response('file size limit 5MB', { status: 400 });
      }

      // 1.根据图片获取食物描述
      const blob = await imageFile.arrayBuffer();
      const input = {
          image: [...new Uint8Array(blob)],
          prompt: `
          List every food item visible in this image. For each item, provide:
          1. Exact food name
          2. Quantity or amount
          3. Preparation style if visible
          4. State if uncertain about anything
          `,
          max_tokens: 512,
      };
      const response = await env.AI.run(
          "@cf/llava-hf/llava-1.5-7b-hf",
          input
      );

      if (response.description.includes("None")) {
          return new Response(JSON.stringify(response));
      }

      // 2.根据食物描述获取热量
      const prompt = `
          You are a professional nutritionist. Please refer to the description to provide accurate calorie and nutritional value estimates.
          ## description
          ${response.description}

          ## Important Guidelines
          1. Provide accurate calorie and nutrient estimates.
          2. If there are uncertain foods in the description, choose the one with the highest probability.
          3. Reply in Chinese
      `;
      const data = await env.AI.run('@cf/meta/llama-3.3-70b-instruct-fp8-fast', {
          messages: [
              {
                  role: 'system',
                  content: prompt,
              }, 
              {
                  role: 'user',
                  content: response.description,
              }
          ], 
          response_format: {
              "type": "json_schema",
              "json_schema": {
                  "type": "array",
                  "items": {
                      "type": "object",
                      "properties": {
                          "food": {
                              "type": "string"
                          },
                          "count": {
                              "type": "integer"
                          },
                          "nutrition": {
                              "type": "object",
                              "properties": {
                                  "calories": {
                                      "type": "integer"
                                  },
                                  "protein": {
                                      "type": "integer"
                                  },
                                  "carbs": {
                                      "type": "integer"
                                  },
                                  "fat": {
                                      "type": "integer"
                                  }
                              }
                          }
                      }
                  }
              }
          }
      });
      
      return new Response(JSON.stringify(data));
  } catch (error) {
      return new Response(error.message, { status: 500 });
  }
}

async function foodSave(request, env) {
  try{
      const{ user_id, content, type } = await request.json();

      const currentDate = new Date().toISOString().split('T')[0];
      const exist = await env.DB.prepare('SELECT count(*) as count FROM food_diary WHERE user_id = ? and type = ? and date = ?').bind(user_id, type, currentDate).first();
      if (exist.count > 0) {
          await env.DB.prepare('UPDATE food_diary SET content = ? WHERE user_id = ? and type = ?').bind(JSON.stringify(content), user_id, type).run();
      } else {
          await env.DB.prepare('INSERT INTO food_diary (user_id, content, type) VALUES (?, ?, ?)').bind(user_id, JSON.stringify(content), type).run();
      }

      return new Response(JSON.stringify({result: true}));
  } catch (error) {
      return new Response(error.message, { status: 500 });
  }
}

async function foodQuery(request, env) {
  try{
      const{ user_id } = await request.json();

      const foodList = await env.DB.prepare('SELECT * FROM food_diary WHERE user_id = ?').bind(user_id).all();
      const results = transform(foodList.results);

      return new Response(JSON.stringify(results));
  } catch (error) {
      return new Response(error.message, { status: 500 });
  }
}

function transform(array) {
  return array.map(item => {
      try {
          const contentArray = JSON.parse(item.content);
          const foodNames = contentArray.map(foodItem => foodItem.food);
          const name = foodNames.join('、');
          
          let totalCalories = 0;
          let totalProtein = 0;
          let totalCarbs = 0;
          let totalFat = 0;
          
          contentArray.forEach(foodItem => {
              const nutrition = foodItem.nutrition;
              totalCalories += nutrition.calories || 0;
              totalProtein += nutrition.protein || 0;
              totalCarbs += nutrition.carbs || 0;
              totalFat += nutrition.fat || 0;
          });
          
          return {
              user_id: item.user_id,
              name: name,
              mealType: item.type,
              calories: Math.round(totalCalories),
              protein: Math.round(totalProtein),
              carbs: Math.round(totalCarbs),
              fat: Math.round(totalFat),
              date: item.date,
          };
          
      } catch (error) {
          console.error(error);
          return null;
      }
  }).filter(item => item !== null)
}
